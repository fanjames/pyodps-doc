# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2018, The Alibaba Group Holding Ltd.
# This file is distributed under the same license as the PyODPS package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyODPS 0.7.16\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-13 10:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../../source/base-tables.rst:4
msgid "表"
msgstr ""

#: ../../source/base-tables.rst:6
msgid ""
"`表 <https://docs.aliyun.com/#/pub/odps/basic/definition&table>`_ "
"是ODPS的数据存储单元。"
msgstr ""

#: ../../source/base-tables.rst:9 ../../source/base-tables.rst:306
msgid "基本操作"
msgstr ""

#: ../../source/base-tables.rst:11
msgid "我们可以用 ODPS 入口对象的 ``list_tables`` 来列出项目空间下的所有表。"
msgstr ""

#: ../../source/base-tables.rst:13
msgid ""
"for table in o.list_tables():\n"
"    # 处理每个表"
msgstr ""

#: ../../source/base-tables.rst:18
msgid "通过调用 ``exist_table`` 来判断表是否存在。"
msgstr ""

#: ../../source/base-tables.rst:20
msgid "通过调用 ``get_table`` 来获取表。"
msgstr ""

#: ../../source/base-tables.rst:22
msgid ""
">>> t = o.get_table('dual')\n"
">>> t.schema\n"
"odps.Schema {\n"
"  c_int_a                 bigint\n"
"  c_int_b                 bigint\n"
"  c_double_a              double\n"
"  c_double_b              double\n"
"  c_string_a              string\n"
"  c_string_b              string\n"
"  c_bool_a                boolean\n"
"  c_bool_b                boolean\n"
"  c_datetime_a            datetime\n"
"  c_datetime_b            datetime\n"
"}\n"
">>> t.lifecycle\n"
"-1\n"
">>> print(t.creation_time)\n"
"2014-05-15 14:58:43\n"
">>> t.is_virtual_view\n"
"False\n"
">>> t.size\n"
"1408\n"
">>> t.comment\n"
"'Dual Table Comment'\n"
">>> t.schema.columns\n"
"[<column c_int_a, type bigint>,\n"
" <column c_int_b, type bigint>,\n"
" <column c_double_a, type double>,\n"
" <column c_double_b, type double>,\n"
" <column c_string_a, type string>,\n"
" <column c_string_b, type string>,\n"
" <column c_bool_a, type boolean>,\n"
" <column c_bool_b, type boolean>,\n"
" <column c_datetime_a, type datetime>,\n"
" <column c_datetime_b, type datetime>]\n"
">>> t.schema['c_int_a']\n"
"<column c_int_a, type bigint>\n"
">>> t.schema['c_int_a'].comment\n"
"'Comment of column c_int_a'"
msgstr ""

#: ../../source/base-tables.rst:65
msgid "通过提供 ``project`` 参数，来跨project获取表。"
msgstr ""

#: ../../source/base-tables.rst:67
msgid ">>> t = o.get_table('dual', project='other_project')"
msgstr ""

#: ../../source/base-tables.rst:75
msgid "创建表的Schema"
msgstr ""

#: ../../source/base-tables.rst:77
msgid "有两种方法来初始化。第一种方式通过表的列、以及可选的分区来初始化。"
msgstr ""

#: ../../source/base-tables.rst:79
msgid ""
">>> from odps.models import Schema, Column, Partition\n"
">>> columns = [Column(name='num', type='bigint', comment='the column'),\n"
">>>            Column(name='num2', type='double', comment='the column2')]"
"\n"
">>> partitions = [Partition(name='pt', type='string', comment='the "
"partition')]\n"
">>> schema = Schema(columns=columns, partitions=partitions)\n"
">>> schema.columns\n"
"[<column num, type bigint>,\n"
" <column num2, type double>,\n"
" <partition pt, type string>]\n"
">>> schema.partitions\n"
"[<partition pt, type string>]\n"
">>> schema.names  # 获取非分区字段的字段名\n"
"['num', 'num2']\n"
">>> schema.types  # 获取非分区字段的字段类型\n"
"[bigint, double]"
msgstr ""

#: ../../source/base-tables.rst:98
msgid "第二种方法是使用 ``Schema.from_lists``，这种方法更容易调用，但显然无法直接设置列和分区的注释了。"
msgstr ""

#: ../../source/base-tables.rst:100
msgid ""
">>> schema = Schema.from_lists(['num', 'num2'], ['bigint', 'double'], "
"['pt'], ['string'])\n"
">>> schema.columns\n"
"[<column num, type bigint>,\n"
" <column num2, type double>,\n"
" <partition pt, type string>]"
msgstr ""

#: ../../source/base-tables.rst:109
msgid "创建表"
msgstr ""

#: ../../source/base-tables.rst:111
msgid "可以使用表 schema 来创建表，方法如下："
msgstr ""

#: ../../source/base-tables.rst:113
msgid ""
">>> table = o.create_table('my_new_table', schema)\n"
">>> table = o.create_table('my_new_table', schema, if_not_exists=True)  #"
" 只有不存在表时才创建\n"
">>> table = o.create_table('my_new_table', schema, lifecycle=7)  # 设置生命周期"
msgstr ""

#: ../../source/base-tables.rst:120
msgid "更简单的方式是采用“字段名 字段类型”字符串来创建表，方法如下："
msgstr ""

#: ../../source/base-tables.rst:122
msgid ""
">>> table = o.create_table('my_new_table', 'num bigint, num2 double', "
"if_not_exists=True)\n"
">>> # 创建分区表可传入 (表字段列表, 分区字段列表)\n"
">>> table = o.create_table('my_new_table', ('num bigint, num2 double', "
"'pt string'), if_not_exists=True)"
msgstr ""

#: ../../source/base-tables.rst:129
msgid ""
"在未经设置的情况下，创建表时，只允许使用 bigint、double、decimal、string、datetime、boolean、map 和 "
"array 类型。 如果你使用的是位于公共云上的服务，或者支持 tinyint、struct 等新类型，可以设置 "
"``options.sql.use_odps2_extension = True`` 打开这些类型的支持，示例如下："
msgstr ""

#: ../../source/base-tables.rst:133
msgid ""
">>> from odps import options\n"
">>> options.sql.use_odps2_extension = True\n"
">>> table = o.create_table('my_new_table', 'cat smallint, content "
"struct<title:varchar(100), body string>')"
msgstr ""

#: ../../source/base-tables.rst:141
msgid "同步表更新"
msgstr ""

#: ../../source/base-tables.rst:143
msgid "有时候，一个表可能被别的程序做了更新，比如schema有了变化。此时可以调用 ``reload`` 方法来更新。"
msgstr ""

#: ../../source/base-tables.rst:145
msgid ">>> table.reload()"
msgstr ""

#: ../../source/base-tables.rst:151
msgid "行记录Record"
msgstr ""

#: ../../source/base-tables.rst:153
msgid "Record表示表的一行记录，我们在 Table 对象上调用 new_record 就可以创建一个新的 Record。"
msgstr ""

#: ../../source/base-tables.rst:155
msgid ""
">>> t = o.get_table('mytable')\n"
">>> r = t.new_record(['val0', 'val1'])  # 值的个数必须等于表schema的字段数\n"
">>> r2 = t.new_record()  #  也可以不传入值\n"
">>> r2[0] = 'val0' # 可以通过偏移设置值\n"
">>> r2['field1'] = 'val1'  # 也可以通过字段名设置值\n"
">>> r2.field1 = 'val1'  # 通过属性设置值\n"
">>>\n"
">>> print(record[0])  # 取第0个位置的值\n"
">>> print(record['c_double_a'])  # 通过字段取值\n"
">>> print(record.c_double_a)  # 通过属性取值\n"
">>> print(record[0: 3])  # 切片操作\n"
">>> print(record[0, 2, 3])  # 取多个位置的值\n"
">>> print(record['c_int_a', 'c_double_a'])  # 通过多个字段取值"
msgstr ""

#: ../../source/base-tables.rst:175
msgid "获取表数据"
msgstr ""

#: ../../source/base-tables.rst:177
msgid "有若干种方法能够获取表数据。首先，如果只是查看每个表的开始的小于1万条数据，则可以使用 ``head`` 方法。"
msgstr ""

#: ../../source/base-tables.rst:179
msgid ""
">>> t = o.get_table('dual')\n"
">>> for record in t.head(3):\n"
">>>     # 处理每个Record对象"
msgstr ""

#: ../../source/base-tables.rst:188
msgid "其次，在table上可以执行 ``open_reader`` 操作来打一个reader来读取数据。"
msgstr ""

#: ../../source/base-tables.rst:190 ../../source/base-tables.rst:224
msgid "使用 with 表达式的写法："
msgstr ""

#: ../../source/base-tables.rst:192
msgid ""
">>> with t.open_reader(partition='pt=test') as reader:\n"
">>>     count = reader.count\n"
">>>     for record in reader[5:10]  # "
"可以执行多次，直到将count数量的record读完，这里可以改造成并行操作\n"
">>>         # 处理一条记录"
msgstr ""

#: ../../source/base-tables.rst:199 ../../source/base-tables.rst:246
msgid "不使用 with 表达式的写法："
msgstr ""

#: ../../source/base-tables.rst:201
msgid ""
">>> reader = t.open_reader(partition='pt=test')\n"
">>> count = reader.count\n"
">>> for record in reader[5:10]  # 可以执行多次，直到将count数量的record读完，这里可以改造成并行操作\n"
">>>     # 处理一条记录"
msgstr ""

#: ../../source/base-tables.rst:208
msgid "更简单的调用方法是使用 ODPS 对象的 ``read_table`` 方法，例如"
msgstr ""

#: ../../source/base-tables.rst:210
msgid ""
">>> for record in o.read_table('test_table', partition='pt=test'):\n"
">>>     # 处理一条记录"
msgstr ""

#: ../../source/base-tables.rst:220
msgid "向表写数据"
msgstr ""

#: ../../source/base-tables.rst:222
msgid "类似于 ``open_reader``，table对象同样能执行 ``open_writer`` 来打开writer，并写数据。"
msgstr ""

#: ../../source/base-tables.rst:226
msgid ""
">>> with t.open_writer(partition='pt=test') as writer:\n"
">>>     records = [[111, 'aaa', True],                 # 这里可以是list\n"
">>>                [222, 'bbb', False],\n"
">>>                [333, 'ccc', True],\n"
">>>                [444, '中文', False]]\n"
">>>     writer.write(records)  # 这里records可以是可迭代对象\n"
">>>\n"
">>>     records = [t.new_record([111, 'aaa', True]),   # 也可以是Record对象\n"
">>>                t.new_record([222, 'bbb', False]),\n"
">>>                t.new_record([333, 'ccc', True]),\n"
">>>                t.new_record([444, '中文', False])]\n"
">>>     writer.write(records)\n"
">>>\n"
">>> with t.open_writer(partition='pt=test', blocks=[0, 1]) as writer:  # "
"这里同是打开两个block\n"
">>>     writer.write(0, gen_records(block=0))\n"
">>>     writer.write(1, gen_records(block=1))  # "
"这里两个写操作可以多线程并行，各个block间是独立的\n"
">>>"
msgstr ""

#: ../../source/base-tables.rst:248
msgid ""
">>> writer = t.open_writer(partition='pt=test', blocks=[0, 1])\n"
">>> writer.write(0, gen_records(block=0))\n"
">>> writer.write(1, gen_records(block=1))\n"
">>> writer.close()  # 不要忘记关闭 writer，否则数据可能写入不完全"
msgstr ""

#: ../../source/base-tables.rst:255
msgid "如果分区不存在，可以使用 ``create_partition`` 参数指定创建分区，如"
msgstr ""

#: ../../source/base-tables.rst:257
msgid ""
">>> with t.open_writer(partition='pt=test', create_partition=True) as "
"writer:\n"
">>>     records = [[111, 'aaa', True],                 # 这里可以是list\n"
">>>                [222, 'bbb', False],\n"
">>>                [333, 'ccc', True],\n"
">>>                [444, '中文', False]]\n"
">>>     writer.write(records)  # 这里records可以是可迭代对象"
msgstr ""

#: ../../source/base-tables.rst:266
msgid "更简单的写数据方法是使用 ODPS 对象的 write_table 方法，例如"
msgstr ""

#: ../../source/base-tables.rst:268
msgid ""
">>> records = [[111, 'aaa', True],                 # 这里可以是list\n"
">>>            [222, 'bbb', False],\n"
">>>            [333, 'ccc', True],\n"
">>>            [444, '中文', False]]\n"
">>> o.write_table('test_table', records, partition='pt=test', "
"create_partition=True)"
msgstr ""

#: ../../source/base-tables.rst:278
msgid ""
"**注意**\\ ：每次调用 write_table，MaxCompute 都会在服务端生成一个文件。这一操作需要较大的时间开销， "
"同时过多的文件会降低后续的查询效率。因此，我们建议在使用 write_table 方法时，一次性写入多组数据， 或者传入一个 generator "
"对象。"
msgstr ""

#: ../../source/base-tables.rst:283
msgid "删除表"
msgstr ""

#: ../../source/base-tables.rst:285
msgid ""
">>> o.delete_table('my_table_name', if_exists=True)  #  只有表存在时删除\n"
">>> t.drop()  # Table对象存在的时候可以直接执行drop函数"
msgstr ""

#: ../../source/base-tables.rst:292
msgid "创建DataFrame"
msgstr ""

#: ../../source/base-tables.rst:294
msgid ""
"PyODPS提供了 :ref:`DataFrame框架 <df>` ，支持更方便地方式来查询和操作ODPS数据。 使用 ``to_df`` "
"方法，即可转化为 DataFrame 对象。"
msgstr ""

#: ../../source/base-tables.rst:297
msgid ""
">>> table = o.get_table('my_table_name')\n"
">>> df = table.to_df()"
msgstr ""

#: ../../source/base-tables.rst:303
msgid "表分区"
msgstr ""

#: ../../source/base-tables.rst:308
msgid "判断是否为分区表："
msgstr ""

#: ../../source/base-tables.rst:310
#, python-format
msgid ""
">>> if table.schema.partitions:\n"
">>>     print('Table %s is partitioned.' % table.name)"
msgstr ""

#: ../../source/base-tables.rst:315
msgid "遍历表全部分区："
msgstr ""

#: ../../source/base-tables.rst:317
msgid ""
">>> for partition in table.partitions:\n"
">>>     print(partition.name)\n"
">>> for partition in table.iterate_partitions(spec='pt=test'):\n"
">>>     # 遍历二级分区"
msgstr ""

#: ../../source/base-tables.rst:324
msgid "判断分区是否存在："
msgstr ""

#: ../../source/base-tables.rst:326
msgid ">>> table.exist_partition('pt=test,sub=2015')"
msgstr ""

#: ../../source/base-tables.rst:330
msgid "获取分区："
msgstr ""

#: ../../source/base-tables.rst:332
msgid ""
">>> partition = table.get_partition('pt=test')\n"
">>> print(partition.creation_time)\n"
"2015-11-18 22:22:27\n"
">>> partition.size\n"
"0"
msgstr ""

#: ../../source/base-tables.rst:341
msgid "创建分区"
msgstr ""

#: ../../source/base-tables.rst:343
msgid ">>> t.create_partition('pt=test', if_not_exists=True)  # 不存在的时候才创建"
msgstr ""

#: ../../source/base-tables.rst:348
msgid "删除分区"
msgstr ""

#: ../../source/base-tables.rst:350
msgid ""
">>> t.delete_partition('pt=test', if_exists=True)  # 存在的时候才删除\n"
">>> partition.drop()  # Partition对象存在的时候直接drop"
msgstr ""

#: ../../source/base-tables.rst:358
msgid "数据上传下载通道"
msgstr ""

#: ../../source/base-tables.rst:363
msgid ""
"不推荐直接使用tunnel接口（难用且复杂），推荐直接使用表的 :ref:`写 <table_write>` 和 :ref:`读 "
"<table_read>` 接口。"
msgstr ""

#: ../../source/base-tables.rst:367
msgid "ODPS Tunnel是ODPS的数据通道，用户可以通过Tunnel向ODPS中上传或者下载数据。"
msgstr ""

#: ../../source/base-tables.rst:369
msgid "**注意**，如果安装了 **Cython**，在安装pyodps时会编译C代码，加速Tunnel的上传和下载。"
msgstr ""

#: ../../source/base-tables.rst:372
msgid "上传"
msgstr ""

#: ../../source/base-tables.rst:374
msgid ""
"from odps.tunnel import TableTunnel\n"
"\n"
"table = o.get_table('my_table')\n"
"\n"
"tunnel = TableTunnel(odps)\n"
"upload_session = tunnel.create_upload_session(table.name, "
"partition_spec='pt=test')\n"
"\n"
"with upload_session.open_record_writer(0) as writer:\n"
"    record = table.new_record()\n"
"    record[0] = 'test1'\n"
"    record[1] = 'id1'\n"
"    writer.write(record)\n"
"\n"
"    record = table.new_record(['test2', 'id2'])\n"
"    writer.write(record)\n"
"\n"
"upload_session.commit([0])"
msgstr ""

#: ../../source/base-tables.rst:395
msgid "下载"
msgstr ""

#: ../../source/base-tables.rst:398
msgid ""
"from odps.tunnel import TableTunnel\n"
"\n"
"tunnel = TableTunnel(odps)\n"
"download_session = tunnel.create_download_session('my_table', "
"partition_spec='pt=test')\n"
"\n"
"with download_session.open_record_reader(0, download_session.count) as "
"reader:\n"
"    for record in reader:\n"
"        # 处理每条记录"
msgstr ""

